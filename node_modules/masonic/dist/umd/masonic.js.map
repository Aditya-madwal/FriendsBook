{"version":3,"file":"masonic.js","sources":["../../src/interval-tree.ts","../../node_modules/.pnpm/@react-hook+event@1.2.6_react@17.0.2/node_modules/@react-hook/event/src/index.tsx","../../src/use-force-update.ts","../../src/use-masonry.tsx","../../node_modules/.pnpm/@react-hook+throttle@2.2.0_react@17.0.2/node_modules/@react-hook/throttle/src/index.tsx","../../src/use-scroller.ts","../../node_modules/.pnpm/@essentials+request-timeout@1.3.0/node_modules/@essentials/request-timeout/src/index.ts","../../src/masonry-scroller.tsx","../../src/use-container-position.ts","../../src/use-positioner.ts","../../src/use-resize-observer.ts","../../src/use-scroll-to-index.ts","../../src/masonry.tsx","../../node_modules/.pnpm/@react-hook+window-size@3.1.1_react@17.0.2/node_modules/@react-hook/window-size/src/index.tsx","../../node_modules/.pnpm/@react-hook+debounce@3.0.0_react@17.0.2/node_modules/@react-hook/debounce/src/index.tsx","../../node_modules/.pnpm/@react-hook+latest@1.0.3_react@17.0.2/node_modules/@react-hook/latest/src/index.tsx","../../node_modules/.pnpm/@essentials+memoize-one@1.1.0/node_modules/@essentials/memoize-one/src/index.ts","../../node_modules/.pnpm/@essentials+one-key-map@1.2.0/node_modules/@essentials/one-key-map/src/index.ts","../../node_modules/.pnpm/trie-memoize@1.2.0/node_modules/trie-memoize/src/index.ts","../../src/elements-cache.ts","../../node_modules/.pnpm/@essentials+raf@1.2.0/node_modules/@essentials/raf/src/index.ts","../../node_modules/.pnpm/@react-hook+window-scroll@1.3.0_react@17.0.2/node_modules/@react-hook/window-scroll/src/index.tsx","../../node_modules/.pnpm/@react-hook+passive-layout-effect@1.2.1_react@17.0.2/node_modules/@react-hook/passive-layout-effect/src/index.tsx","../../node_modules/.pnpm/raf-schd@4.0.3/node_modules/raf-schd/dist/raf-schd.esm.js","../../src/use-infinite-loader.ts","../../src/list.tsx"],"sourcesContent":["type Color = 0 | 1 | 2;\nconst RED = 0;\nconst BLACK = 1;\nconst NIL = 2;\n\nconst DELETE = 0;\nconst KEEP = 1;\n\ntype ListNode = {\n  index: number;\n  high: number;\n  next: ListNode | null;\n};\n\ninterface TreeNode {\n  max: number;\n  low: number;\n  high: number;\n  // color\n  C: Color;\n  // P\n  P: TreeNode;\n  // right\n  R: TreeNode;\n  // left\n  L: TreeNode;\n  list: ListNode;\n}\n\ninterface Tree {\n  root: TreeNode;\n  size: number;\n}\n\nfunction addInterval(treeNode: TreeNode, high: number, index: number): boolean {\n  let node: ListNode | null = treeNode.list;\n  let prevNode: ListNode | undefined;\n\n  while (node) {\n    if (node.index === index) return false;\n    if (high > node.high) break;\n    prevNode = node;\n    node = node.next;\n  }\n\n  if (!prevNode) treeNode.list = { index, high, next: node };\n  if (prevNode) prevNode.next = { index, high, next: prevNode.next };\n\n  return true;\n}\n\nfunction removeInterval(treeNode: TreeNode, index: number) {\n  let node: ListNode | null = treeNode.list;\n  if (node.index === index) {\n    if (node.next === null) return DELETE;\n    treeNode.list = node.next;\n    return KEEP;\n  }\n\n  let prevNode: ListNode | undefined = node;\n  node = node.next;\n\n  while (node !== null) {\n    if (node.index === index) {\n      prevNode.next = node.next;\n      return KEEP;\n    }\n    prevNode = node;\n    node = node.next;\n  }\n}\n\nconst NULL_NODE: TreeNode = {\n  low: 0,\n  max: 0,\n  high: 0,\n  C: NIL,\n  // @ts-expect-error\n  P: undefined,\n  // @ts-expect-error\n  R: undefined,\n  // @ts-expect-error\n  L: undefined,\n  // @ts-expect-error\n  list: undefined,\n};\n\nNULL_NODE.P = NULL_NODE;\nNULL_NODE.L = NULL_NODE;\nNULL_NODE.R = NULL_NODE;\n\nfunction updateMax(node: TreeNode) {\n  const max = node.high;\n  if (node.L === NULL_NODE && node.R === NULL_NODE) node.max = max;\n  else if (node.L === NULL_NODE) node.max = Math.max(node.R.max, max);\n  else if (node.R === NULL_NODE) node.max = Math.max(node.L.max, max);\n  else node.max = Math.max(Math.max(node.L.max, node.R.max), max);\n}\n\nfunction updateMaxUp(node: TreeNode) {\n  let x = node;\n\n  while (x.P !== NULL_NODE) {\n    updateMax(x.P);\n    x = x.P;\n  }\n}\n\nfunction rotateLeft(tree: Tree, x: TreeNode) {\n  if (x.R === NULL_NODE) return;\n  const y = x.R;\n  x.R = y.L;\n  if (y.L !== NULL_NODE) y.L.P = x;\n  y.P = x.P;\n\n  if (x.P === NULL_NODE) tree.root = y;\n  else if (x === x.P.L) x.P.L = y;\n  else x.P.R = y;\n\n  y.L = x;\n  x.P = y;\n\n  updateMax(x);\n  updateMax(y);\n}\n\nfunction rotateRight(tree: Tree, x: TreeNode) {\n  if (x.L === NULL_NODE) return;\n  const y = x.L;\n  x.L = y.R;\n  if (y.R !== NULL_NODE) y.R.P = x;\n  y.P = x.P;\n\n  if (x.P === NULL_NODE) tree.root = y;\n  else if (x === x.P.R) x.P.R = y;\n  else x.P.L = y;\n\n  y.R = x;\n  x.P = y;\n\n  updateMax(x);\n  updateMax(y);\n}\n\nfunction replaceNode(tree: Tree, x: TreeNode, y: TreeNode) {\n  if (x.P === NULL_NODE) tree.root = y;\n  else if (x === x.P.L) x.P.L = y;\n  else x.P.R = y;\n  y.P = x.P;\n}\n\nfunction fixRemove(tree: Tree, x: TreeNode) {\n  let w;\n\n  while (x !== NULL_NODE && x.C === BLACK) {\n    if (x === x.P.L) {\n      w = x.P.R;\n\n      if (w.C === RED) {\n        w.C = BLACK;\n        x.P.C = RED;\n        rotateLeft(tree, x.P);\n        w = x.P.R;\n      }\n\n      if (w.L.C === BLACK && w.R.C === BLACK) {\n        w.C = RED;\n        x = x.P;\n      } else {\n        if (w.R.C === BLACK) {\n          w.L.C = BLACK;\n          w.C = RED;\n          rotateRight(tree, w);\n          w = x.P.R;\n        }\n\n        w.C = x.P.C;\n        x.P.C = BLACK;\n        w.R.C = BLACK;\n        rotateLeft(tree, x.P);\n        x = tree.root;\n      }\n    } else {\n      w = x.P.L;\n\n      if (w.C === RED) {\n        w.C = BLACK;\n        x.P.C = RED;\n        rotateRight(tree, x.P);\n        w = x.P.L;\n      }\n\n      if (w.R.C === BLACK && w.L.C === BLACK) {\n        w.C = RED;\n        x = x.P;\n      } else {\n        if (w.L.C === BLACK) {\n          w.R.C = BLACK;\n          w.C = RED;\n          rotateLeft(tree, w);\n          w = x.P.L;\n        }\n\n        w.C = x.P.C;\n        x.P.C = BLACK;\n        w.L.C = BLACK;\n        rotateRight(tree, x.P);\n        x = tree.root;\n      }\n    }\n  }\n\n  x.C = BLACK;\n}\n\nfunction minimumTree(x: TreeNode) {\n  while (x.L !== NULL_NODE) x = x.L;\n  return x;\n}\n\nfunction fixInsert(tree: Tree, z: TreeNode) {\n  let y: TreeNode;\n  while (z.P.C === RED) {\n    if (z.P === z.P.P.L) {\n      y = z.P.P.R;\n\n      if (y.C === RED) {\n        z.P.C = BLACK;\n        y.C = BLACK;\n        z.P.P.C = RED;\n        z = z.P.P;\n      } else {\n        if (z === z.P.R) {\n          z = z.P;\n          rotateLeft(tree, z);\n        }\n\n        z.P.C = BLACK;\n        z.P.P.C = RED;\n        rotateRight(tree, z.P.P);\n      }\n    } else {\n      y = z.P.P.L;\n\n      if (y.C === RED) {\n        z.P.C = BLACK;\n        y.C = BLACK;\n        z.P.P.C = RED;\n        z = z.P.P;\n      } else {\n        if (z === z.P.L) {\n          z = z.P;\n          rotateRight(tree, z);\n        }\n\n        z.P.C = BLACK;\n        z.P.P.C = RED;\n        rotateLeft(tree, z.P.P);\n      }\n    }\n  }\n  tree.root.C = BLACK;\n}\n\nexport interface IIntervalTree {\n  insert(low: number, high: number, index: number): void;\n  remove(index: number): void;\n  search(\n    low: number,\n    high: number,\n    callback: (index: number, low: number) => any\n  ): void;\n  size: number;\n}\n\nexport function createIntervalTree(): IIntervalTree {\n  const tree = {\n    root: NULL_NODE,\n    size: 0,\n  };\n  // we know these indexes are a consistent, safe way to make look ups\n  // for our case so it's a solid O(1) alternative to\n  // the O(log n) searchNode() in typical interval trees\n  const indexMap: Record<number, TreeNode> = {};\n\n  return {\n    insert(low, high, index) {\n      let x: TreeNode = tree.root;\n      let y: TreeNode = NULL_NODE;\n\n      while (x !== NULL_NODE) {\n        y = x;\n        if (low === y.low) break;\n        if (low < x.low) x = x.L;\n        else x = x.R;\n      }\n\n      if (low === y.low && y !== NULL_NODE) {\n        if (!addInterval(y, high, index)) return;\n        y.high = Math.max(y.high, high);\n        updateMax(y);\n        updateMaxUp(y);\n        indexMap[index] = y;\n        tree.size++;\n        return;\n      }\n\n      const z: TreeNode = {\n        low,\n        high,\n        max: high,\n        C: RED,\n        P: y,\n        L: NULL_NODE,\n        R: NULL_NODE,\n        list: { index, high, next: null },\n      };\n\n      if (y === NULL_NODE) {\n        tree.root = z;\n      } else {\n        if (z.low < y.low) y.L = z;\n        else y.R = z;\n        updateMaxUp(z);\n      }\n\n      fixInsert(tree, z);\n      indexMap[index] = z;\n      tree.size++;\n    },\n\n    remove(index) {\n      const z = indexMap[index];\n      if (z === void 0) return;\n      delete indexMap[index];\n\n      const intervalResult = removeInterval(z, index);\n      if (intervalResult === void 0) return;\n      if (intervalResult === KEEP) {\n        z.high = z.list.high;\n        updateMax(z);\n        updateMaxUp(z);\n        tree.size--;\n        return;\n      }\n\n      let y = z;\n      let originalYColor = y.C;\n      let x: TreeNode;\n\n      if (z.L === NULL_NODE) {\n        x = z.R;\n        replaceNode(tree, z, z.R);\n      } else if (z.R === NULL_NODE) {\n        x = z.L;\n        replaceNode(tree, z, z.L);\n      } else {\n        y = minimumTree(z.R);\n        originalYColor = y.C;\n        x = y.R;\n\n        if (y.P === z) {\n          x.P = y;\n        } else {\n          replaceNode(tree, y, y.R);\n          y.R = z.R;\n          y.R.P = y;\n        }\n\n        replaceNode(tree, z, y);\n        y.L = z.L;\n        y.L.P = y;\n        y.C = z.C;\n      }\n\n      updateMax(x);\n      updateMaxUp(x);\n\n      if (originalYColor === BLACK) fixRemove(tree, x);\n      tree.size--;\n    },\n\n    search(low, high, callback) {\n      const stack = [tree.root];\n      while (stack.length !== 0) {\n        const node = stack.pop() as TreeNode;\n        if (node === NULL_NODE || low > node.max) continue;\n        if (node.L !== NULL_NODE) stack.push(node.L);\n        if (node.R !== NULL_NODE) stack.push(node.R);\n        if (node.low <= high && node.high >= low) {\n          let curr: ListNode | null = node.list;\n          while (curr !== null) {\n            if (curr.high >= low) callback(curr.index, node.low);\n            curr = curr.next;\n          }\n        }\n      }\n    },\n\n    get size() {\n      return tree.size;\n    },\n  };\n}\n","import * as React from 'react'\n\nfunction useEvent<\n  T extends Window = Window,\n  K extends keyof WindowEventMap = keyof WindowEventMap\n>(\n  target: Window | null,\n  type: K,\n  listener: WindowEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends Document = Document,\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n>(\n  target: Document | null,\n  type: K,\n  listener: DocumentEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends HTMLElement = HTMLElement,\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n>(\n  target: React.RefObject<T> | T | null,\n  type: K,\n  listener: ElementEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent(target: any, type: any, listener: any, cleanup: any): void {\n  const storedListener = React.useRef(listener)\n  const storedCleanup = React.useRef(cleanup)\n\n  React.useEffect(() => {\n    storedListener.current = listener\n    storedCleanup.current = cleanup\n  })\n\n  React.useEffect(() => {\n    const targetEl = target && 'current' in target ? target.current : target\n    if (!targetEl) return\n\n    let didUnsubscribe = 0\n    function listener(this: any, ...args: any[]) {\n      if (didUnsubscribe) return\n      storedListener.current.apply(this, args)\n    }\n\n    targetEl.addEventListener(type, listener)\n    const cleanup = storedCleanup.current\n\n    return () => {\n      didUnsubscribe = 1\n      targetEl.removeEventListener(type, listener)\n      cleanup && cleanup()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [target, type])\n}\n\nexport type ElementEventListener<\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n> = (this: HTMLElement, ev: HTMLElementEventMap[K]) => any\n\nexport type DocumentEventListener<\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n> = (this: Document, ev: DocumentEventMap[K]) => any\n\nexport type WindowEventListener<\n  K extends keyof WindowEventMap = keyof WindowEventMap\n> = (this: Document, ev: WindowEventMap[K]) => any\n\nexport default useEvent\n","import * as React from \"react\";\n\nexport function useForceUpdate() {\n  const setState = React.useState(emptyObj)[1];\n  return React.useRef(() => setState({})).current;\n}\n\nconst emptyObj = {};\n","import memoizeOne from \"@essentials/memoize-one\";\nimport OneKeyMap from \"@essentials/one-key-map\";\nimport useLatest from \"@react-hook/latest\";\nimport * as React from \"react\";\nimport trieMemoize from \"trie-memoize\";\nimport { elementsCache } from \"./elements-cache\";\nimport { useForceUpdate } from \"./use-force-update\";\nimport type { Positioner } from \"./use-positioner\";\n\n/**\n * This hook handles the render phases of the masonry layout and returns the grid as a React element.\n *\n * @param options - Options for configuring the masonry layout renderer. See `UseMasonryOptions`.\n * @param options.positioner\n * @param options.resizeObserver\n * @param options.items\n * @param options.as\n * @param options.id\n * @param options.className\n * @param options.style\n * @param options.role\n * @param options.tabIndex\n * @param options.containerRef\n * @param options.itemAs\n * @param options.itemStyle\n * @param options.itemHeightEstimate\n * @param options.itemKey\n * @param options.overscanBy\n * @param options.scrollTop\n * @param options.isScrolling\n * @param options.height\n * @param options.render\n * @param options.onRender\n */\nexport function useMasonry<Item>({\n  // Measurement and layout\n  positioner,\n  resizeObserver,\n  // Grid items\n  items,\n  // Container props\n  as: ContainerComponent = \"div\",\n  id,\n  className,\n  style,\n  role = \"grid\",\n  tabIndex = 0,\n  containerRef,\n  // Item props\n  itemAs: ItemComponent = \"div\",\n  itemStyle,\n  itemHeightEstimate = 300,\n  itemKey = defaultGetItemKey,\n  // Rendering props\n  overscanBy = 2,\n  scrollTop,\n  isScrolling,\n  height,\n  render: RenderComponent,\n  onRender,\n}: UseMasonryOptions<Item>) {\n  let startIndex = 0;\n  let stopIndex: number | undefined;\n  const forceUpdate = useForceUpdate();\n  const setItemRef = getRefSetter(positioner, resizeObserver);\n  const itemCount = items.length;\n  const {\n    columnWidth,\n    columnCount,\n    range,\n    estimateHeight,\n    size,\n    shortestColumn,\n  } = positioner;\n  const measuredCount = size();\n  const shortestColumnSize = shortestColumn();\n  const children: React.ReactElement[] = [];\n  const itemRole =\n    role === \"list\" ? \"listitem\" : role === \"grid\" ? \"gridcell\" : undefined;\n  const storedOnRender = useLatest(onRender);\n\n  overscanBy = height * overscanBy;\n  const rangeEnd = scrollTop + overscanBy;\n  const needsFreshBatch =\n    shortestColumnSize < rangeEnd && measuredCount < itemCount;\n\n  range(\n    // We overscan in both directions because users scroll both ways,\n    // though one must admit scrolling down is more common and thus\n    // we only overscan by half the downward overscan amount\n    Math.max(0, scrollTop - overscanBy / 2),\n    rangeEnd,\n    (index, left, top) => {\n      const data = items[index];\n      const key = itemKey(data, index);\n      const phaseTwoStyle: React.CSSProperties = {\n        top,\n        left,\n        width: columnWidth,\n        writingMode: \"horizontal-tb\",\n        position: \"absolute\",\n      };\n\n      /* istanbul ignore next */\n      if (\n        typeof process !== \"undefined\" &&\n        process.env.NODE_ENV !== \"production\"\n      ) {\n        throwWithoutData(data, index);\n      }\n\n      children.push(\n        <ItemComponent\n          key={key}\n          ref={setItemRef(index)}\n          role={itemRole}\n          style={\n            typeof itemStyle === \"object\" && itemStyle !== null\n              ? Object.assign({}, phaseTwoStyle, itemStyle)\n              : phaseTwoStyle\n          }\n        >\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\n        </ItemComponent>\n      );\n\n      if (stopIndex === void 0) {\n        startIndex = index;\n        stopIndex = index;\n      } else {\n        startIndex = Math.min(startIndex, index);\n        stopIndex = Math.max(stopIndex, index);\n      }\n    }\n  );\n\n  if (needsFreshBatch) {\n    const batchSize = Math.min(\n      itemCount - measuredCount,\n      Math.ceil(\n        ((scrollTop + overscanBy - shortestColumnSize) / itemHeightEstimate) *\n          columnCount\n      )\n    );\n\n    let index = measuredCount;\n    const phaseOneStyle = getCachedSize(columnWidth);\n\n    for (; index < measuredCount + batchSize; index++) {\n      const data = items[index];\n      const key = itemKey(data, index);\n\n      /* istanbul ignore next */\n      if (\n        typeof process !== \"undefined\" &&\n        process.env.NODE_ENV !== \"production\"\n      ) {\n        throwWithoutData(data, index);\n      }\n\n      children.push(\n        <ItemComponent\n          key={key}\n          ref={setItemRef(index)}\n          role={itemRole}\n          style={\n            typeof itemStyle === \"object\"\n              ? Object.assign({}, phaseOneStyle, itemStyle)\n              : phaseOneStyle\n          }\n        >\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\n        </ItemComponent>\n      );\n    }\n  }\n\n  // Calls the onRender callback if the rendered indices changed\n  React.useEffect(() => {\n    if (typeof storedOnRender.current === \"function\" && stopIndex !== void 0)\n      storedOnRender.current(startIndex, stopIndex, items);\n\n    didEverMount = \"1\";\n  }, [startIndex, stopIndex, items, storedOnRender]);\n  // If we needed a fresh batch we should reload our components with the measured\n  // sizes\n  React.useEffect(() => {\n    if (needsFreshBatch) forceUpdate();\n    // eslint-disable-next-line\n  }, [needsFreshBatch, positioner]);\n\n  // gets the container style object based upon the estimated height and whether or not\n  // the page is being scrolled\n  const containerStyle = getContainerStyle(\n    isScrolling,\n    estimateHeight(itemCount, itemHeightEstimate)\n  );\n\n  return (\n    <ContainerComponent\n      ref={containerRef}\n      key={didEverMount}\n      id={id}\n      role={role}\n      className={className}\n      tabIndex={tabIndex}\n      style={\n        typeof style === \"object\"\n          ? assignUserStyle(containerStyle, style)\n          : containerStyle\n      }\n      children={children}\n    />\n  );\n}\n\n/* istanbul ignore next */\nfunction throwWithoutData(data: any, index: number) {\n  if (!data) {\n    throw new Error(\n      `No data was found at index: ${index}\\n\\n` +\n        `This usually happens when you've mutated or changed the \"items\" array in a ` +\n        `way that makes it shorter than the previous \"items\" array. Masonic knows nothing ` +\n        `about your underlying data and when it caches cell positions, it assumes you aren't ` +\n        `mutating the underlying \"items\".\\n\\n` +\n        `See https://codesandbox.io/s/masonic-w-react-router-example-2b5f9?file=/src/index.js for ` +\n        `an example that gets around this limitations. For advanced implementations, see ` +\n        `https://codesandbox.io/s/masonic-w-react-router-and-advanced-config-example-8em42?file=/src/index.js\\n\\n` +\n        `If this was the result of your removing an item from your \"items\", see this issue: ` +\n        `https://github.com/jaredLunde/masonic/issues/12`\n    );\n  }\n}\n\n// This is for triggering a remount after SSR has loaded in the client w/ hydrate()\nlet didEverMount = \"0\";\n\nexport interface UseMasonryOptions<Item> {\n  /**\n   * An array containing the data used by the grid items.\n   */\n  items: Item[];\n  /**\n   * A grid cell positioner and cache created by the `usePositioner()` hook or\n   * the `createPositioner` utility.\n   */\n  positioner: Positioner;\n  /**\n   * A resize observer that tracks mutations to the grid cells and forces the\n   * Masonry grid to recalculate its layout if any cells affect column heights\n   * change. Check out the `useResizeObserver()` hook.\n   */\n  resizeObserver?: {\n    observe: ResizeObserver[\"observe\"];\n    disconnect: ResizeObserver[\"observe\"];\n    unobserve: ResizeObserver[\"unobserve\"];\n  };\n  /**\n   * This is the type of element the grid container will be rendered as.\n   *\n   * @default \"div\"`\n   */\n  as?: keyof JSX.IntrinsicElements | React.ComponentType<any>;\n  /**\n   * Optionally gives the grid container an `id` prop.\n   */\n  id?: string;\n  /**\n   * Optionally gives the grid container a `className` prop.\n   */\n  className?: string;\n  /**\n   * Adds extra `style` attributes to the container in addition to those\n   * created by the `useMasonry()` hook.\n   */\n  style?: React.CSSProperties;\n  /**\n   * Optionally swap out the accessibility `role` prop of the container and its items.\n   *\n   * @default \"grid\"\n   */\n  role?: \"grid\" | \"list\";\n  /**\n   * Change the `tabIndex` of the grid container.\n   *\n   * @default 0\n   */\n  tabIndex?: number;\n  /**\n   * Forwards a React ref to the grid container.\n   */\n  containerRef?:\n    | ((element: HTMLElement) => void)\n    | React.MutableRefObject<HTMLElement | null>;\n  /**\n   * This is the type of element the grid items will be rendered as.\n   *\n   * @default \"div\"\n   */\n  itemAs?: keyof JSX.IntrinsicElements | React.ComponentType<any>;\n  /**\n   * Adds extra `style` attributes to the grid items in addition to those\n   * created by the `useMasonry()` hook.\n   */\n  itemStyle?: React.CSSProperties;\n  /**\n   * This value is used for estimating the initial height of the masonry grid. It is important for\n   * the UX of the scrolling behavior and in determining how many `items` to render in a batch, so it's\n   * wise to set this value with some level accuracy, though it doesn't need to be perfect.\n   *\n   * @default 300\n   */\n  itemHeightEstimate?: number;\n  /**\n   * The value returned here must be unique to the item. By default, the key is the item's index. This is ok\n   * if your collection of items is never modified. Setting this property ensures that the component in `render`\n   * is reused each time the masonry grid is reflowed. A common pattern would be to return the item's database\n   * ID here if there is one, e.g. `data => data.id`\n   *\n   * @default (data, index) => index`\n   */\n  itemKey?: (data: Item, index: number) => string | number;\n  /**\n   * This number is used for determining the number of grid cells outside of the visible window to render.\n   * The default value is `2` which means \"render 2 windows worth (2 * `height`) of content before and after\n   * the items in the visible window\". A value of `3` would be 3 windows worth of grid cells, so it's a\n   * linear relationship.\n   *\n   * Overscanning is important for preventing tearing when scrolling through items in the grid, but setting\n   * too high of a vaimport { useForceUpdate } from './use-force-update';\nlue may create too much work for React to handle, so it's best that you tune this\n   * value accordingly.\n   *\n   * @default 2\n   */\n  overscanBy?: number;\n\n  /**\n   * This is the height of the window. If you're rendering the grid relative to the browser `window`,\n   * the current `document.documentElement.clientHeight` is the value you'll want to set here. If you're\n   * rendering the grid inside of another HTML element, you'll want to provide the current `element.offsetHeight`\n   * here.\n   */\n  height: number;\n  /**\n   * The current scroll progress in pixel of the window the grid is rendered in. If you're rendering\n   * the grid relative to the browser `window`, you'll want the most current `window.scrollY` here.\n   * If you're rendering the grid inside of another HTML element, you'll want the current `element.scrollTop`\n   * value here. The `useScroller()` hook and `<MasonryScroller>` components will help you if you're\n   * rendering the grid relative to the browser `window`.\n   */\n  scrollTop: number;\n  /**\n   * This property is used for determining whether or not the grid container should add styles that\n   * dramatically increase scroll performance. That is, turning off `pointer-events` and adding a\n   * `will-change: contents;` value to the style string. You can forgo using this prop, but I would\n   * not recommend that. The `useScroller()` hook and `<MasonryScroller>` components will help you if\n   * you're rendering the grid relative to the browser `window`.\n   *\n   * @default false\n   */\n  isScrolling?: boolean;\n  /**\n   * This component is rendered for each item of your `items` prop array. It should accept three props:\n   * `index`, `width`, and `data`. See RenderComponentProps.\n   */\n  render: React.ComponentType<RenderComponentProps<Item>>;\n  /**\n   * This callback is invoked any time the items currently being rendered by the grid change.\n   */\n  onRender?: (startIndex: number, stopIndex: number, items: Item[]) => void;\n}\n\nexport interface RenderComponentProps<Item> {\n  /**\n   * The index of the cell in the `items` prop array.\n   */\n  index: number;\n  /**\n   * The rendered width of the cell's column.\n   */\n  width: number;\n  /**\n   * The data at `items[index]` of your `items` prop array.\n   */\n  data: Item;\n}\n\n//\n// Render-phase utilities\n\n// ~5.5x faster than createElement without the memo\nconst createRenderElement = trieMemoize(\n  [OneKeyMap, {}, WeakMap, OneKeyMap],\n  (RenderComponent, index, data, columnWidth) => (\n    <RenderComponent index={index} data={data} width={columnWidth} />\n  )\n);\n\nconst getContainerStyle = memoizeOne(\n  (isScrolling: boolean | undefined, estimateHeight: number) => ({\n    position: \"relative\",\n    width: \"100%\",\n    maxWidth: \"100%\",\n    height: Math.ceil(estimateHeight),\n    maxHeight: Math.ceil(estimateHeight),\n    willChange: isScrolling ? \"contents\" : void 0,\n    pointerEvents: isScrolling ? \"none\" : void 0,\n  })\n);\n\nconst cmp2 = (args: IArguments, pargs: IArguments | any[]): boolean =>\n  args[0] === pargs[0] && args[1] === pargs[1];\n\nconst assignUserStyle = memoizeOne(\n  (containerStyle, userStyle) => Object.assign({}, containerStyle, userStyle),\n  // @ts-expect-error\n  cmp2\n);\n\nfunction defaultGetItemKey<Item>(_: Item, i: number) {\n  return i;\n}\n\n// the below memoizations for for ensuring shallow equal is reliable for pure\n// component children\nconst getCachedSize = memoizeOne(\n  (width: number): React.CSSProperties => ({\n    width,\n    zIndex: -1000,\n    visibility: \"hidden\",\n    position: \"absolute\",\n    writingMode: \"horizontal-tb\",\n  }),\n  (args, pargs) => args[0] === pargs[0]\n);\n\nconst getRefSetter = memoizeOne(\n  (\n      positioner: Positioner,\n      resizeObserver?: UseMasonryOptions<any>[\"resizeObserver\"]\n    ) =>\n    (index: number) =>\n    (el: HTMLElement | null): void => {\n      if (el === null) return;\n      if (resizeObserver) {\n        resizeObserver.observe(el);\n        elementsCache.set(el, index);\n      }\n      if (positioner.get(index) === void 0)\n        positioner.set(index, el.offsetHeight);\n    },\n  // @ts-expect-error\n  cmp2\n);\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\nconst perf = typeof performance !== 'undefined' ? performance : Date\nconst now = () => perf.now()\n\nexport function useThrottleCallback<CallbackArguments extends any[]>(\n  callback: (...args: CallbackArguments) => void,\n  fps = 30,\n  leading = false\n): (...args: CallbackArguments) => void {\n  const storedCallback = useLatest(callback)\n  const ms = 1000 / fps\n  const prev = React.useRef(0)\n  const trailingTimeout = React.useRef<ReturnType<typeof setTimeout>>()\n  const clearTrailing = () =>\n    trailingTimeout.current && clearTimeout(trailingTimeout.current)\n  const deps = [fps, leading, storedCallback]\n\n  // Reset any time the deps change\n  React.useEffect(\n    () => () => {\n      prev.current = 0\n      clearTrailing()\n    },\n    deps\n  )\n\n  return React.useCallback(function () {\n    // eslint-disable-next-line prefer-rest-params\n    const args = arguments\n    const rightNow = now()\n    const call = () => {\n      prev.current = rightNow\n      clearTrailing()\n      storedCallback.current.apply(null, args as any)\n    }\n    const current = prev.current\n    // leading\n    if (leading && current === 0) return call()\n    // body\n    if (rightNow - current > ms) {\n      if (current > 0) return call()\n      prev.current = rightNow\n    }\n    // trailing\n    clearTrailing()\n    trailingTimeout.current = setTimeout(() => {\n      call()\n      prev.current = 0\n    }, ms)\n  }, deps)\n}\n\nexport function useThrottle<State>(\n  initialState: State | (() => State),\n  fps?: number,\n  leading?: boolean\n): [State, React.Dispatch<React.SetStateAction<State>>] {\n  const state = React.useState<State>(initialState)\n  return [state[0], useThrottleCallback(state[1], fps, leading)]\n}\n","import {\n  clearRequestTimeout,\n  requestTimeout,\n} from \"@essentials/request-timeout\";\nimport useScrollPosition from \"@react-hook/window-scroll\";\nimport * as React from \"react\";\n\n/**\n * A hook for tracking whether the `window` is currently being scrolled and it's scroll position on\n * the y-axis. These values are used for determining which grid cells to render and when\n * to add styles to the masonry container that maximize scroll performance.\n *\n * @param offset - The vertical space in pixels between the top of the grid container and the top\n *  of the browser `document.documentElement`.\n * @param fps - This determines how often (in frames per second) to update the scroll position of the\n *  browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n *  The default value of `12` has been very reasonable in my own testing, but if you have particularly\n *  heavy `render` components it may be prudent to reduce this number.\n */\nexport function useScroller(\n  offset = 0,\n  fps = 12\n): { scrollTop: number; isScrolling: boolean } {\n  const scrollTop = useScrollPosition(fps);\n  const [isScrolling, setIsScrolling] = React.useState(false);\n  const didMount = React.useRef(0);\n\n  React.useEffect(() => {\n    if (didMount.current === 1) setIsScrolling(true);\n    let didUnsubscribe = false;\n    const to = requestTimeout(() => {\n      if (didUnsubscribe) return;\n      // This is here to prevent premature bail outs while maintaining high resolution\n      // unsets. Without it there will always bee a lot of unnecessary DOM writes to style.\n      setIsScrolling(false);\n    }, 40 + 1000 / fps);\n    didMount.current = 1;\n    return () => {\n      didUnsubscribe = true;\n      clearRequestTimeout(to);\n    };\n  }, [fps, scrollTop]);\n\n  return { scrollTop: Math.max(0, scrollTop - offset), isScrolling };\n}\n","/**\n * Copyright 2011, Joe Lambert.\n * Free to use under the MIT license.\n * http://www.opensource.org/licenses/mit-license.php\n **/\nimport {raf, caf, now} from '@essentials/raf'\n\nexport interface RequestTimeoutHandle {\n  v?: number\n}\n\nexport const clearRequestTimeout = (handle: RequestTimeoutHandle): void => {\n  caf(handle.v || -1)\n}\n\nexport const requestTimeout = (\n  fn: (...args: any[]) => void,\n  ms: number\n): RequestTimeoutHandle => {\n  const start = now(),\n    handle: RequestTimeoutHandle = {}\n\n  const loop = () => {\n    now() - start >= ms ? fn.call(null) : (handle.v = raf(loop))\n  }\n\n  handle.v = raf(loop)\n  return handle\n}\n\nexport default requestTimeout\n","import { useMasonry } from \"./use-masonry\";\nimport type { UseMasonryOptions } from \"./use-masonry\";\nimport { useScroller } from \"./use-scroller\";\n/**\n * A heavily-optimized component that updates `useMasonry()` when the scroll position of the browser `window`\n * changes. This bare-metal component is used by `<Masonry>` under the hood.\n *\n * @param props\n */\nexport function MasonryScroller<Item>(props: MasonryScrollerProps<Item>) {\n  // We put this in its own layer because it's the thing that will trigger the most updates\n  // and we don't want to slower ourselves by cycling through all the functions, objects, and effects\n  // of other hooks\n  const { scrollTop, isScrolling } = useScroller(props.offset, props.scrollFps);\n  // This is an update-heavy phase and while we could just Object.assign here,\n  // it is way faster to inline and there's a relatively low hit to he bundle\n  // size.\n  return useMasonry<Item>({\n    scrollTop,\n    isScrolling,\n    positioner: props.positioner,\n    resizeObserver: props.resizeObserver,\n    items: props.items,\n    onRender: props.onRender,\n    as: props.as,\n    id: props.id,\n    className: props.className,\n    style: props.style,\n    role: props.role,\n    tabIndex: props.tabIndex,\n    containerRef: props.containerRef,\n    itemAs: props.itemAs,\n    itemStyle: props.itemStyle,\n    itemHeightEstimate: props.itemHeightEstimate,\n    itemKey: props.itemKey,\n    overscanBy: props.overscanBy,\n    height: props.height,\n    render: props.render,\n  });\n}\n\nexport interface MasonryScrollerProps<Item>\n  extends Omit<UseMasonryOptions<Item>, \"scrollTop\" | \"isScrolling\"> {\n  /**\n   * This determines how often (in frames per second) to update the scroll position of the\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\n   * heavy `render` components it may be prudent to reduce this number.\n   *\n   * @default 12\n   */\n  scrollFps?: number;\n  /**\n   * The vertical space in pixels between the top of the grid container and the top\n   * of the browser `document.documentElement`.\n   *\n   * @default 0\n   */\n  offset?: number;\n}\n\nif (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n  MasonryScroller.displayName = \"MasonryScroller\";\n}\n","import useLayoutEffect from \"@react-hook/passive-layout-effect\";\nimport * as React from \"react\";\n\n/**\n * A hook for measuring the width of the grid container, as well as its distance\n * from the top of the document. These values are necessary to correctly calculate the number/width\n * of columns to render, as well as the number of rows to render.\n *\n * @param elementRef - A `ref` object created by `React.useRef()`. That ref should be provided to the\n *   `containerRef` property in `useMasonry()`.\n * @param deps - You can force this hook to recalculate the `offset` and `width` whenever this\n *   dependencies list changes. A common dependencies list might look like `[windowWidth, windowHeight]`,\n *   which would force the hook to recalculate any time the size of the browser `window` changed.\n */\nexport function useContainerPosition(\n  elementRef: React.MutableRefObject<HTMLElement | null>,\n  deps: React.DependencyList = emptyArr\n): ContainerPosition {\n  const [containerPosition, setContainerPosition] =\n    React.useState<ContainerPosition>({ offset: 0, width: 0 });\n\n  useLayoutEffect(() => {\n    const { current } = elementRef;\n    if (current !== null) {\n      let offset = 0;\n      let el = current;\n\n      do {\n        offset += el.offsetTop || 0;\n        el = el.offsetParent as HTMLElement;\n      } while (el);\n\n      if (\n        offset !== containerPosition.offset ||\n        current.offsetWidth !== containerPosition.width\n      ) {\n        setContainerPosition({\n          offset,\n          width: current.offsetWidth,\n        });\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n\n  return containerPosition;\n}\n\nexport interface ContainerPosition {\n  /**\n   * The distance in pixels between the top of the element in `elementRef` and the top of\n   * the `document.documentElement`.\n   */\n  offset: number;\n  /**\n   * The `offsetWidth` of the element in `elementRef`.\n   */\n  width: number;\n}\n\nconst emptyArr: [] = [];\n","import * as React from \"react\";\nimport { createIntervalTree } from \"./interval-tree\";\n\n/**\n * This hook creates the grid cell positioner and cache required by `useMasonry()`. This is\n * the meat of the grid's layout algorithm, determining which cells to render at a given scroll\n * position, as well as where to place new items in the grid.\n *\n * @param options - Properties that determine the number of columns in the grid, as well\n *  as their widths.\n * @param options.columnWidth\n * @param options.width\n * @param deps - This hook will create a new positioner, clearing all existing cached positions,\n *  whenever the dependencies in this list change.\n * @param options.columnGutter\n * @param options.rowGutter\n * @param options.columnCount\n * @param options.maxColumnCount\n */\nexport function usePositioner(\n  {\n    width,\n    columnWidth = 200,\n    columnGutter = 0,\n    rowGutter,\n    columnCount,\n    maxColumnCount,\n  }: UsePositionerOptions,\n  deps: React.DependencyList = emptyArr\n): Positioner {\n  const initPositioner = (): Positioner => {\n    const [computedColumnWidth, computedColumnCount] = getColumns(\n      width,\n      columnWidth,\n      columnGutter,\n      columnCount,\n      maxColumnCount\n    );\n    return createPositioner(\n      computedColumnCount,\n      computedColumnWidth,\n      columnGutter,\n      rowGutter ?? columnGutter\n    );\n  };\n  const positionerRef = React.useRef<Positioner>();\n  if (positionerRef.current === undefined)\n    positionerRef.current = initPositioner();\n\n  const prevDeps = React.useRef(deps);\n  const opts = [\n    width,\n    columnWidth,\n    columnGutter,\n    rowGutter,\n    columnCount,\n    maxColumnCount,\n  ];\n  const prevOpts = React.useRef(opts);\n  const optsChanged = !opts.every((item, i) => prevOpts.current[i] === item);\n\n  if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n    if (deps.length !== prevDeps.current.length) {\n      throw new Error(\n        \"usePositioner(): The length of your dependencies array changed.\"\n      );\n    }\n  }\n\n  // Create a new positioner when the dependencies or sizes change\n  // Thanks to https://github.com/khmm12 for pointing this out\n  // https://github.com/jaredLunde/masonic/pull/41\n  if (optsChanged || !deps.every((item, i) => prevDeps.current[i] === item)) {\n    const prevPositioner = positionerRef.current;\n    const positioner = initPositioner();\n    prevDeps.current = deps;\n    prevOpts.current = opts;\n\n    if (optsChanged) {\n      const cacheSize = prevPositioner.size();\n      for (let index = 0; index < cacheSize; index++) {\n        const pos = prevPositioner.get(index);\n        positioner.set(index, pos !== void 0 ? pos.height : 0);\n      }\n    }\n\n    positionerRef.current = positioner;\n  }\n\n  return positionerRef.current;\n}\n\nexport interface UsePositionerOptions {\n  /**\n   * The width of the container you're rendering the grid within, i.e. the container\n   * element's `element.offsetWidth`\n   */\n  width: number;\n  /**\n   * The minimum column width. The `usePositioner()` hook will automatically size the\n   * columns to fill their container based upon the `columnWidth` and `columnGutter` values.\n   * It will never render anything smaller than this width unless its container itself is\n   * smaller than its value. This property is optional if you're using a static `columnCount`.\n   *\n   * @default 200\n   */\n  columnWidth?: number;\n  /**\n   * This sets the horizontal space between grid columns in pixels. If `rowGutter` is not set, this\n   * also sets the vertical space between cells within a column in pixels.\n   *\n   * @default 0\n   */\n  columnGutter?: number;\n  /**\n   * This sets the vertical space between cells within a column in pixels. If not set, the value of\n   * `columnGutter` is used instead.\n   */\n  rowGutter?: number;\n  /**\n   * By default, `usePositioner()` derives the column count from the `columnWidth`, `columnGutter`,\n   * and `width` props. However, in some situations it is nice to be able to override that behavior\n   * (e.g. creating a `List` component).\n   */\n  columnCount?: number;\n  /**\n   * The upper bound of column count. This property won't work if `columnCount` is set.\n   */\n  maxColumnCount?: number;\n}\n\n/**\n * Creates a cell positioner for the `useMasonry()` hook. The `usePositioner()` hook uses\n * this utility under the hood.\n *\n * @param columnCount - The number of columns in the grid\n * @param columnWidth - The width of each column in the grid\n * @param columnGutter - The amount of horizontal space between columns in pixels.\n * @param rowGutter - The amount of vertical space between cells within a column in pixels (falls back\n * to `columnGutter`).\n */\nexport const createPositioner = (\n  columnCount: number,\n  columnWidth: number,\n  columnGutter = 0,\n  rowGutter = columnGutter\n): Positioner => {\n  // O(log(n)) lookup of cells to render for a given viewport size\n  // Store tops and bottoms of each cell for fast intersection lookup.\n  const intervalTree = createIntervalTree();\n  // Track the height of each column.\n  // Layout algorithm below always inserts into the shortest column.\n  const columnHeights: number[] = new Array(columnCount);\n  // Used for O(1) item access\n  const items: PositionerItem[] = [];\n  // Tracks the item indexes within an individual column\n  const columnItems: number[][] = new Array(columnCount);\n\n  for (let i = 0; i < columnCount; i++) {\n    columnHeights[i] = 0;\n    columnItems[i] = [];\n  }\n\n  return {\n    columnCount,\n    columnWidth,\n    set: (index, height = 0) => {\n      let column = 0;\n\n      // finds the shortest column and uses it\n      for (let i = 1; i < columnHeights.length; i++) {\n        if (columnHeights[i] < columnHeights[column]) column = i;\n      }\n\n      const top = columnHeights[column] || 0;\n      columnHeights[column] = top + height + rowGutter;\n      columnItems[column].push(index);\n      items[index] = {\n        left: column * (columnWidth + columnGutter),\n        top,\n        height,\n        column,\n      };\n      intervalTree.insert(top, top + height, index);\n    },\n    get: (index) => items[index],\n    // This only updates items in the specific columns that have changed, on and after the\n    // specific items that have changed\n    update: (updates) => {\n      const columns: number[] = new Array(columnCount);\n      let i = 0,\n        j = 0;\n\n      // determines which columns have items that changed, as well as the minimum index\n      // changed in that column, as all items after that index will have their positions\n      // affected by the change\n      for (; i < updates.length - 1; i++) {\n        const index = updates[i];\n        const item = items[index];\n        item.height = updates[++i];\n        intervalTree.remove(index);\n        intervalTree.insert(item.top, item.top + item.height, index);\n        columns[item.column] =\n          columns[item.column] === void 0\n            ? index\n            : Math.min(index, columns[item.column]);\n      }\n\n      for (i = 0; i < columns.length; i++) {\n        // bails out if the column didn't change\n        if (columns[i] === void 0) continue;\n        const itemsInColumn = columnItems[i];\n        // the index order is sorted with certainty so binary search is a great solution\n        // here as opposed to Array.indexOf()\n        const startIndex = binarySearch(itemsInColumn, columns[i]);\n        const index = columnItems[i][startIndex];\n        const startItem = items[index];\n        columnHeights[i] = startItem.top + startItem.height + rowGutter;\n\n        for (j = startIndex + 1; j < itemsInColumn.length; j++) {\n          const index = itemsInColumn[j];\n          const item = items[index];\n          item.top = columnHeights[i];\n          columnHeights[i] = item.top + item.height + rowGutter;\n          intervalTree.remove(index);\n          intervalTree.insert(item.top, item.top + item.height, index);\n        }\n      }\n    },\n    // Render all cells visible within the viewport range defined.\n    range: (lo, hi, renderCallback) =>\n      intervalTree.search(lo, hi, (index, top) =>\n        renderCallback(index, items[index].left, top)\n      ),\n    estimateHeight: (itemCount, defaultItemHeight): number => {\n      const tallestColumn = Math.max(0, Math.max.apply(null, columnHeights));\n\n      return itemCount === intervalTree.size\n        ? tallestColumn\n        : tallestColumn +\n            Math.ceil((itemCount - intervalTree.size) / columnCount) *\n              defaultItemHeight;\n    },\n    shortestColumn: () => {\n      if (columnHeights.length > 1) return Math.min.apply(null, columnHeights);\n      return columnHeights[0] || 0;\n    },\n    size(): number {\n      return intervalTree.size;\n    },\n    all(): PositionerItem[] {\n      return items;\n    },\n  };\n};\n\nexport interface Positioner {\n  /**\n   * The number of columns in the grid\n   */\n  columnCount: number;\n  /**\n   * The width of each column in the grid\n   */\n  columnWidth: number;\n  /**\n   * Sets the position for the cell at `index` based upon the cell's height\n   */\n  set: (index: number, height: number) => void;\n  /**\n   * Gets the `PositionerItem` for the cell at `index`\n   */\n  get: (index: number) => PositionerItem | undefined;\n  /**\n   * Updates cells based on their indexes and heights\n   * positioner.update([index, height, index, height, index, height...])\n   */\n  update: (updates: number[]) => void;\n  /**\n   * Searches the interval tree for grid cells with a `top` value in\n   * betwen `lo` and `hi` and invokes the callback for each item that\n   * is discovered\n   */\n  range: (\n    lo: number,\n    hi: number,\n    renderCallback: (index: number, left: number, top: number) => void\n  ) => void;\n  /**\n   * Returns the number of grid cells in the cache\n   */\n\n  size: () => number;\n  /**\n   * Estimates the total height of the grid\n   */\n\n  estimateHeight: (itemCount: number, defaultItemHeight: number) => number;\n  /**\n   * Returns the height of the shortest column in the grid\n   */\n\n  shortestColumn: () => number;\n  /**\n   * Returns all `PositionerItem` items\n   */\n  all: () => PositionerItem[];\n}\n\nexport interface PositionerItem {\n  /**\n   * This is how far from the top edge of the grid container in pixels the\n   * item is placed\n   */\n  top: number;\n  /**\n   * This is how far from the left edge of the grid container in pixels the\n   * item is placed\n   */\n  left: number;\n  /**\n   * This is the height of the grid cell\n   */\n  height: number;\n  /**\n   * This is the column number containing the grid cell\n   */\n  column: number;\n}\n\n/* istanbul ignore next */\nconst binarySearch = (a: number[], y: number): number => {\n  let l = 0;\n  let h = a.length - 1;\n\n  while (l <= h) {\n    const m = (l + h) >>> 1;\n    const x = a[m];\n    if (x === y) return m;\n    else if (x <= y) l = m + 1;\n    else h = m - 1;\n  }\n\n  return -1;\n};\n\nconst getColumns = (\n  width = 0,\n  minimumWidth = 0,\n  gutter = 8,\n  columnCount?: number,\n  maxColumnCount?: number\n): [number, number] => {\n  columnCount =\n    columnCount ||\n    Math.min(\n      Math.floor((width + gutter) / (minimumWidth + gutter)),\n      maxColumnCount || Infinity\n    ) ||\n    1;\n  const columnWidth = Math.floor(\n    (width - gutter * (columnCount - 1)) / columnCount\n  );\n  return [columnWidth, columnCount];\n};\n\nconst emptyArr: [] = [];\n","import rafSchd from \"raf-schd\";\nimport * as React from \"react\";\nimport trieMemoize from \"trie-memoize\";\nimport { elementsCache } from \"./elements-cache\";\nimport { useForceUpdate } from \"./use-force-update\";\nimport type { Positioner } from \"./use-positioner\";\n\n/**\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\n * made to cells affecting their height.\n *\n * @param positioner - The masonry cell positioner created by the `usePositioner()` hook.\n */\nexport function useResizeObserver(positioner: Positioner) {\n  const forceUpdate = useForceUpdate();\n  const resizeObserver = createResizeObserver(positioner, forceUpdate);\n  // Cleans up the resize observers when they change or the\n  // component unmounts\n  React.useEffect(() => () => resizeObserver.disconnect(), [resizeObserver]);\n  return resizeObserver;\n}\n\nconst _handlerForType = rafSchd((target: HTMLElement) => {});\n\ntype IHandler = typeof _handlerForType;\n\n/**\n * Creates a resize observer that fires an `updater` callback whenever the height of\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\n *\n * @param positioner - A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\n * @param updater - A callback that fires whenever one or many cell heights change.\n */\nexport const createResizeObserver = trieMemoize(\n  [WeakMap],\n  // TODO: figure out a way to test this\n  /* istanbul ignore next */\n  (positioner: Positioner, updater: (updates: number[]) => void) => {\n    const updates: number[] = [];\n\n    const update = rafSchd(() => {\n      if (updates.length > 0) {\n        // Updates the size/positions of the cell with the resize\n        // observer updates\n        positioner.update(updates);\n        updater(updates);\n      }\n      updates.length = 0;\n    });\n\n    const commonHandler = (target: HTMLElement) => {\n      const height = target.offsetHeight;\n      if (height > 0) {\n        const index = elementsCache.get(target);\n        if (index !== void 0) {\n          const position = positioner.get(index);\n          if (position !== void 0 && height !== position.height)\n            updates.push(index, height);\n        }\n      }\n      update();\n    };\n\n    const handlers = new Map<number, IHandler>();\n    const handleEntries: ResizeObserverCallback = (entries) => {\n      let i = 0;\n\n      for (; i < entries.length; i++) {\n        const entry = entries[i];\n        const index = elementsCache.get(entry.target);\n\n        if (index === void 0) continue;\n        let handler = handlers.get(index);\n        if (!handler) {\n          handler = rafSchd(commonHandler);\n          handlers.set(index, handler);\n        }\n        handler(entry.target as HTMLElement);\n      }\n    };\n\n    const ro = new ResizeObserver(handleEntries);\n    // Overrides the original disconnect to include cancelling handling the entries.\n    // Ideally this would be its own method but that would result in a breaking\n    // change.\n    const disconnect = ro.disconnect.bind(ro);\n    ro.disconnect = () => {\n      disconnect();\n      handlers.forEach((handler) => {\n        handler.cancel();\n      });\n    };\n\n    return ro;\n  }\n);\n","import useEvent from \"@react-hook/event\";\nimport useLatest from \"@react-hook/latest\";\nimport { useThrottleCallback } from \"@react-hook/throttle\";\nimport * as React from \"react\";\nimport type { Positioner, PositionerItem } from \"./use-positioner\";\n\n/**\n * A hook that creates a callback for scrolling to a specific index in\n * the \"items\" array.\n *\n * @param positioner - A positioner created by the `usePositioner()` hook\n * @param options - Configuration options\n */\nexport function useScrollToIndex(\n  positioner: Positioner,\n  options: UseScrollToIndexOptions\n) {\n  const {\n    align = \"top\",\n    element = typeof window !== \"undefined\" && window,\n    offset = 0,\n    height = typeof window !== \"undefined\" ? window.innerHeight : 0,\n  } = options;\n  const latestOptions = useLatest({\n    positioner,\n    element,\n    align,\n    offset,\n    height,\n  } as const);\n  const getTarget = React.useRef(() => {\n    const latestElement = latestOptions.current.element;\n    return latestElement && \"current\" in latestElement\n      ? latestElement.current\n      : latestElement;\n  }).current;\n  const [state, dispatch] = React.useReducer(\n    (\n      state: {\n        position: PositionerItem | undefined;\n        index: number | undefined;\n        prevTop: number | undefined;\n      },\n      action:\n        | { type: \"scrollToIndex\"; value: number | undefined }\n        | { type: \"setPosition\"; value: PositionerItem | undefined }\n        | { type: \"setPrevTop\"; value: number | undefined }\n        | { type: \"reset\" }\n    ) => {\n      const nextState = {\n        position: state.position,\n        index: state.index,\n        prevTop: state.prevTop,\n      };\n\n      /* istanbul ignore next */\n      if (action.type === \"scrollToIndex\") {\n        return {\n          position: latestOptions.current.positioner.get(action.value ?? -1),\n          index: action.value,\n          prevTop: void 0,\n        };\n      } else if (action.type === \"setPosition\") {\n        nextState.position = action.value;\n      } else if (action.type === \"setPrevTop\") {\n        nextState.prevTop = action.value;\n      } else if (action.type === \"reset\") {\n        return defaultState;\n      }\n\n      return nextState;\n    },\n    defaultState\n  );\n  const throttledDispatch = useThrottleCallback(dispatch, 15);\n\n  // If we find the position along the way we can immediately take off\n  // to the correct spot.\n  useEvent(getTarget() as Window, \"scroll\", () => {\n    if (!state.position && state.index) {\n      const position = latestOptions.current.positioner.get(state.index);\n\n      if (position) {\n        dispatch({ type: \"setPosition\", value: position });\n      }\n    }\n  });\n\n  // If the top changes out from under us in the case of dynamic cells, we\n  // want to keep following it.\n  const currentTop =\n    state.index !== void 0 &&\n    latestOptions.current.positioner.get(state.index)?.top;\n\n  React.useEffect(() => {\n    const target = getTarget();\n    if (!target) return;\n    const { height, align, offset, positioner } = latestOptions.current;\n\n    if (state.position) {\n      let scrollTop = state.position.top;\n\n      if (align === \"bottom\") {\n        scrollTop = scrollTop - height + state.position.height;\n      } else if (align === \"center\") {\n        scrollTop -= (height - state.position.height) / 2;\n      }\n\n      target.scrollTo(0, Math.max(0, (scrollTop += offset)));\n      // Resets state after 400ms, an arbitrary time I determined to be\n      // still visually pleasing if there is a slow network reply in dynamic\n      // cells\n      let didUnsubscribe = false;\n      const timeout = setTimeout(\n        () => !didUnsubscribe && dispatch({ type: \"reset\" }),\n        400\n      );\n      return () => {\n        didUnsubscribe = true;\n        clearTimeout(timeout);\n      };\n    } else if (state.index !== void 0) {\n      // Estimates the top based upon the average height of current cells\n      let estimatedTop =\n        (positioner.shortestColumn() / positioner.size()) * state.index;\n      if (state.prevTop)\n        estimatedTop = Math.max(estimatedTop, state.prevTop + height);\n      target.scrollTo(0, estimatedTop);\n      throttledDispatch({ type: \"setPrevTop\", value: estimatedTop });\n    }\n  }, [currentTop, state, latestOptions, getTarget, throttledDispatch]);\n\n  return React.useRef((index: number) => {\n    dispatch({ type: \"scrollToIndex\", value: index });\n  }).current;\n}\n\nconst defaultState = {\n  index: void 0,\n  position: void 0,\n  prevTop: void 0,\n} as const;\n\nexport type UseScrollToIndexOptions = {\n  /**\n   * The window element or a React ref for the window element. That is,\n   * this is the grid container.\n   *\n   * @default window\n   */\n  element?: Window | HTMLElement | React.RefObject<HTMLElement> | null;\n  /**\n   * Sets the vertical alignment of the cell within the grid container.\n   *\n   * @default \"top\"\n   */\n  align?: \"center\" | \"top\" | \"bottom\";\n  /**\n   * The height of the grid.\n   *\n   * @default window.innerHeight\n   */\n  height?: number;\n  /**\n   * The vertical space in pixels between the top of the grid container and the top\n   * of the window.\n   *\n   * @default 0\n   */\n  offset?: number;\n};\n","import { useWindowSize } from \"@react-hook/window-size\";\nimport * as React from \"react\";\nimport { MasonryScroller } from \"./masonry-scroller\";\nimport type { MasonryScrollerProps } from \"./masonry-scroller\";\nimport { useContainerPosition } from \"./use-container-position\";\nimport { usePositioner } from \"./use-positioner\";\nimport type { UsePositionerOptions } from \"./use-positioner\";\nimport { useResizeObserver } from \"./use-resize-observer\";\nimport { useScrollToIndex } from \"./use-scroll-to-index\";\nimport type { UseScrollToIndexOptions } from \"./use-scroll-to-index\";\n\n/**\n * A \"batteries included\" masonry grid which includes all of the implementation details below. This component is the\n * easiest way to get off and running in your app, before switching to more advanced implementations, if necessary.\n * It will change its column count to fit its container's width and will decide how many rows to render based upon\n * the height of the browser `window`.\n *\n * @param props\n */\nexport function Masonry<Item>(props: MasonryProps<Item>) {\n  const containerRef = React.useRef<null | HTMLElement>(null);\n  const windowSize = useWindowSize({\n    initialWidth: props.ssrWidth,\n    initialHeight: props.ssrHeight,\n  });\n  const containerPos = useContainerPosition(containerRef, windowSize);\n  const nextProps = Object.assign(\n    {\n      offset: containerPos.offset,\n      width: containerPos.width || windowSize[0],\n      height: windowSize[1],\n      containerRef,\n    },\n    props\n  ) as any;\n  nextProps.positioner = usePositioner(nextProps);\n  nextProps.resizeObserver = useResizeObserver(nextProps.positioner);\n  const scrollToIndex = useScrollToIndex(nextProps.positioner, {\n    height: nextProps.height,\n    offset: containerPos.offset,\n    align:\n      typeof props.scrollToIndex === \"object\"\n        ? props.scrollToIndex.align\n        : void 0,\n  });\n  const index =\n    props.scrollToIndex &&\n    (typeof props.scrollToIndex === \"number\"\n      ? props.scrollToIndex\n      : props.scrollToIndex.index);\n\n  React.useEffect(() => {\n    if (index !== void 0) scrollToIndex(index);\n  }, [index, scrollToIndex]);\n\n  return React.createElement(MasonryScroller, nextProps);\n}\n\nexport interface MasonryProps<Item>\n  extends Omit<\n      MasonryScrollerProps<Item>,\n      \"offset\" | \"width\" | \"height\" | \"containerRef\" | \"positioner\"\n    >,\n    Pick<\n      UsePositionerOptions,\n      | \"columnWidth\"\n      | \"columnGutter\"\n      | \"rowGutter\"\n      | \"columnCount\"\n      | \"maxColumnCount\"\n    > {\n  /**\n   * Scrolls to a given index within the grid. The grid will re-scroll\n   * any time the index changes.\n   */\n  scrollToIndex?:\n    | number\n    | {\n        index: number;\n        align: UseScrollToIndexOptions[\"align\"];\n      };\n  /**\n   * This is the width that will be used for the browser `window` when rendering this component in SSR.\n   * This prop isn't relevant for client-side only apps.\n   */\n  ssrWidth?: number;\n  /**\n   * This is the height that will be used for the browser `window` when rendering this component in SSR.\n   * This prop isn't relevant for client-side only apps.\n   */\n  ssrHeight?: number;\n  /**\n   * This determines how often (in frames per second) to update the scroll position of the\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\n   * heavy `render` components it may be prudent to reduce this number.\n   *\n   * @default 12\n   */\n  scrollFps?: number;\n}\n\nif (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n  Masonry.displayName = \"Masonry\";\n}\n","import {useDebounce} from '@react-hook/debounce'\nimport useEvent from '@react-hook/event'\n\nconst emptyObj = {}\n\nexport interface DebouncedWindowSizeOptions {\n  initialWidth?: number\n  initialHeight?: number\n  wait?: number\n  leading?: boolean\n}\n\nconst win = typeof window === 'undefined' ? null : window\nconst wv =\n  win && typeof win.visualViewport !== 'undefined' ? win.visualViewport : null\nconst getSize = () =>\n  [\n    document.documentElement.clientWidth,\n    document.documentElement.clientHeight,\n  ] as const\n\nexport const useWindowSize = (\n  options: DebouncedWindowSizeOptions = emptyObj\n): readonly [number, number] => {\n  const {wait, leading, initialWidth = 0, initialHeight = 0} = options\n  const [size, setDebouncedSize] = useDebounce<readonly [number, number]>(\n    /* istanbul ignore next */\n    typeof document === 'undefined' ? [initialWidth, initialHeight] : getSize,\n    wait,\n    leading\n  )\n  const setSize = (): void => setDebouncedSize(getSize)\n\n  useEvent(win, 'resize', setSize)\n  // @ts-expect-error\n  useEvent(wv, 'resize', setSize)\n  useEvent(win, 'orientationchange', setSize)\n\n  return size\n}\n\nexport const useWindowHeight = (\n  options?: Omit<DebouncedWindowSizeOptions, 'initialWidth'>\n): number => useWindowSize(options)[1]\n\nexport const useWindowWidth = (\n  options?: Omit<DebouncedWindowSizeOptions, 'initialHeight'>\n): number => useWindowSize(options)[0]\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\nexport const useDebounceCallback = <CallbackArgs extends any[]>(\n  callback: (...args: CallbackArgs) => void,\n  wait = 100,\n  leading = false\n): ((...args: CallbackArgs) => void) => {\n  const storedCallback = useLatest(callback)\n  const timeout = React.useRef<ReturnType<typeof setTimeout>>()\n  const deps = [wait, leading, storedCallback]\n  // Cleans up pending timeouts when the deps change\n  React.useEffect(\n    () => () => {\n      timeout.current && clearTimeout(timeout.current)\n      timeout.current = void 0\n    },\n    deps\n  )\n\n  return React.useCallback(function () {\n    // eslint-disable-next-line prefer-rest-params\n    const args = arguments\n    const {current} = timeout\n    // Calls on leading edge\n    if (current === void 0 && leading) {\n      timeout.current = setTimeout(() => {\n        timeout.current = void 0\n      }, wait)\n      // eslint-disable-next-line prefer-spread\n      return storedCallback.current.apply(null, args as any)\n    }\n    // Clear the timeout every call and start waiting again\n    current && clearTimeout(current)\n    // Waits for `wait` before invoking the callback\n    timeout.current = setTimeout(() => {\n      timeout.current = void 0\n      storedCallback.current.apply(null, args as any)\n    }, wait)\n  }, deps)\n}\n\nexport const useDebounce = <State extends any>(\n  initialState: State | (() => State),\n  wait?: number,\n  leading?: boolean\n): [State, React.Dispatch<React.SetStateAction<State>>] => {\n  const state = React.useState(initialState)\n  return [state[0], useDebounceCallback(state[1], wait, leading)]\n}\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  React.useEffect(() => {\n    storedValue.current = current\n  })\n  return storedValue\n}\n\nexport default useLatest\n","const memoOne = <Args extends any[], T extends any>(\n  fn: (...args: Args) => T,\n  areEqual?: AreEqual<Args>\n): OutputFunction<Args, T> => {\n  const equal = areEqual || defaultAreEqual\n  let args: Args, value: any\n\n  return function (): T {\n    return !!args && equal(arguments as any, args)\n      ? value\n      : (value = fn.apply(null, (args = arguments as any)))\n  } as OutputFunction<Args, T>\n}\n\nexport default memoOne\n\nconst defaultAreEqual = (\n  current: IArguments,\n  prev: IArguments | any[]\n): boolean =>\n  current[0] === prev[0] &&\n  current[1] === prev[1] &&\n  current[2] === prev[2] &&\n  current[3] === prev[3]\n\nexport type AreEqual<Args> = (currentArgs: Args, prevArgs: Args) => boolean\nexport type InputFunction = (...args: any[]) => any\nexport type OutputFunction<Args extends any[], T extends any> = (\n  ...args: Args\n) => T\n","class OneKeyMap<K extends any = any, V extends any = any> {\n  set: (k: K, v: V) => void\n  get: (k: K) => V | undefined\n\n  constructor() {\n    let key: K | undefined, val: V | undefined\n    this.get = (k: K): V | undefined => (k === key ? val : void 0)\n    this.set = (k: K, v: V): void => {\n      key = k\n      val = v\n    }\n  }\n}\n\nexport default OneKeyMap\n","export interface MapLike {\n  new (...args: any[]): any\n}\n\nexport type CacheConstructor =\n  | MapConstructor\n  | WeakMapConstructor\n  | MapLike\n  | Record<any, any>\n\ninterface Cache<K = any, V = any> {\n  set: (k: K, v: V) => V\n  get: (k: K) => V\n}\n\nconst createCache = (obj: CacheConstructor): Cache => {\n  try {\n    // @ts-ignore\n    return new obj()\n  } catch (e) {\n    const cache: Record<string, any> = {}\n\n    return {\n      set(k, v): void {\n        cache[k] = v\n      },\n      get(k): any {\n        return cache[k]\n      },\n    }\n  }\n}\n\nconst memo = (\n  constructors: CacheConstructor[]\n): {s: Cache['set']; g: Cache['get']} => {\n  const depth = constructors.length,\n    baseCache = createCache(constructors[0])\n  let base: any\n  let map: any\n  let i: number\n  let node: typeof baseCache\n  const one = depth === 1\n  // quicker access for one and two-argument functions\n  const g1 = (args: IArguments): any =>\n    (base = baseCache.get(args[0])) === void 0 || one ? base : base.get(args[1])\n  const s1 = (args: IArguments, value: any): any => {\n    if (one) baseCache.set(args[0], value)\n    else {\n      if ((base = baseCache.get(args[0])) === void 0) {\n        map = createCache(constructors[1])\n        map.set(args[1], value)\n        baseCache.set(args[0], map)\n      } else {\n        base.set(args[1], value)\n      }\n    }\n\n    return value\n  }\n\n  const g2 = (args: IArguments): any => {\n    node = baseCache\n\n    for (i = 0; i < depth; i++)\n      if ((node = node.get(args[i])) === void 0) return\n\n    return node\n  }\n\n  const s2 = (args: IArguments, value: any): any => {\n    node = baseCache\n\n    for (i = 0; i < depth - 1; i++) {\n      if ((map = node.get(args[i])) === void 0) {\n        map = createCache(constructors[i + 1])\n        node.set(args[i], map)\n        node = map\n      } else {\n        node = map\n      }\n    }\n\n    node.set(args[depth - 1], value)\n    return value\n  }\n\n  return depth < 3 ? {g: g1, s: s1} : {g: g2, s: s2}\n}\n\nconst memoize = <T extends any[], U extends any>(\n  mapConstructors: CacheConstructor[],\n  fn: (...args: T) => U\n): ((...args: T) => U) => {\n  let item: U\n  const {g, s} = memo(mapConstructors)\n  return function () {\n    return (item = g(arguments)) === void 0\n      ? s(arguments, fn.apply(null, arguments as any))\n      : item\n  }\n}\n\nexport default memoize\n","export const elementsCache: WeakMap<Element, number> = new WeakMap();\n","export type Raf = (callback: (timestamp: number) => void) => number\nexport type Caf = (handle: number) => void\n\nlet u = 'undefined',\n  win = typeof window !== u ? window : ({} as any),\n  p = typeof performance !== u ? performance : Date,\n  now = () => p.now(),\n  af = 'AnimationFrame' as const,\n  Caf = 'cancel' + af,\n  Raf = 'request' + af,\n  raf: Raf = win[Raf] && win[Raf].bind(win),\n  caf: Caf = win[Caf] && win[Caf].bind(win)\n\nif (!raf || !caf) {\n  let lastTime = 0\n  raf = (callback: FrameRequestCallback) => {\n    let curr = now(),\n      next = Math.max(lastTime + 1000 / 60, curr)\n    return setTimeout(() => {\n      callback((lastTime = next))\n    }, next - curr) as any\n  }\n  caf = (h) => clearTimeout(h)\n}\n\nexport {raf, caf, now}\n","import {useThrottle} from '@react-hook/throttle'\nimport useEvent from '@react-hook/event'\n\nconst win = typeof window === 'undefined' ? null : window\nconst getScrollY = (): number =>\n  (win as Window).scrollY !== void 0\n    ? (win as Window).scrollY\n    : (win as Window).pageYOffset === void 0\n    ? 0\n    : (win as Window).pageYOffset\n\nexport const useWindowScroll = (fps = 30): number => {\n  const state = useThrottle(\n    typeof window === 'undefined' ? 0 : getScrollY,\n    fps,\n    true\n  )\n  useEvent(win, 'scroll', (): void => state[1](getScrollY()))\n  return state[0]\n}\n\nexport default useWindowScroll\n","import React from 'react'\n\nconst usePassiveLayoutEffect =\n  React[\n    typeof document !== 'undefined' && document.createElement !== void 0\n      ? 'useLayoutEffect'\n      : 'useEffect'\n  ]\n\nexport default usePassiveLayoutEffect\n","var rafSchd = function rafSchd(fn) {\n  var lastArgs = [];\n  var frameId = null;\n\n  var wrapperFn = function wrapperFn() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n\n    if (frameId) {\n      return;\n    }\n\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      fn.apply(void 0, lastArgs);\n    });\n  };\n\n  wrapperFn.cancel = function () {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n  };\n\n  return wrapperFn;\n};\n\nexport default rafSchd;\n","import useLatest from \"@react-hook/latest\";\nimport * as React from \"react\";\n\n/**\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\n * hook invokes a callback each time the last rendered index surpasses the total number of items\n * in your items array or the number defined in the `totalItems` option.\n *\n * @param loadMoreItems - This callback is invoked when more rows must be loaded. It will be used to\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\n *  as well.\n * @param options\n */\nexport function useInfiniteLoader<Item, T extends LoadMoreItemsCallback<Item>>(\n  loadMoreItems: T,\n  options: UseInfiniteLoaderOptions<Item> = emptyObj\n): LoadMoreItemsCallback<Item> {\n  const {\n    isItemLoaded,\n    minimumBatchSize = 16,\n    threshold = 16,\n    totalItems = 9e9,\n  } = options;\n  const storedLoadMoreItems = useLatest(loadMoreItems);\n  const storedIsItemLoaded = useLatest(isItemLoaded);\n\n  return React.useCallback(\n    (startIndex, stopIndex, items) => {\n      const unloadedRanges = scanForUnloadedRanges(\n        storedIsItemLoaded.current,\n        minimumBatchSize,\n        items,\n        totalItems,\n        Math.max(0, startIndex - threshold),\n        Math.min(totalItems - 1, (stopIndex || 0) + threshold)\n      );\n      // The user is responsible for memoizing their loadMoreItems() function\n      // because we don't want to make assumptions about how they want to deal\n      // with `items`\n      for (let i = 0; i < unloadedRanges.length - 1; ++i)\n        storedLoadMoreItems.current(\n          unloadedRanges[i],\n          unloadedRanges[++i],\n          items\n        );\n    },\n    [\n      totalItems,\n      minimumBatchSize,\n      threshold,\n      storedLoadMoreItems,\n      storedIsItemLoaded,\n    ]\n  );\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n *\n * @param isItemLoaded\n * @param minimumBatchSize\n * @param items\n * @param totalItems\n * @param startIndex\n * @param stopIndex\n */\nfunction scanForUnloadedRanges<Item>(\n  isItemLoaded: UseInfiniteLoaderOptions<Item>[\"isItemLoaded\"] = defaultIsItemLoaded,\n  minimumBatchSize: UseInfiniteLoaderOptions<Item>[\"minimumBatchSize\"] = 16,\n  items: any[],\n  totalItems: UseInfiniteLoaderOptions<Item>[\"totalItems\"] = 9e9,\n  startIndex: number,\n  stopIndex: number\n): number[] {\n  const unloadedRanges: number[] = [];\n  let rangeStartIndex: number | undefined,\n    rangeStopIndex: number | undefined,\n    index = startIndex;\n\n  /* istanbul ignore next */\n  for (; index <= stopIndex; index++) {\n    if (!isItemLoaded(index, items)) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === void 0) rangeStartIndex = index;\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n      rangeStartIndex = rangeStopIndex = void 0;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n    const potentialStopIndex = Math.min(\n      Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1),\n      totalItems - 1\n    );\n\n    /* istanbul ignore next */\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isItemLoaded(index, items)) {\n        rangeStopIndex = index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex);\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  /* istanbul ignore next */\n  if (unloadedRanges.length) {\n    let firstUnloadedStart = unloadedRanges[0];\n    const firstUnloadedStop = unloadedRanges[1];\n\n    while (\n      firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize &&\n      firstUnloadedStart > 0\n    ) {\n      const index = firstUnloadedStart - 1;\n\n      if (!isItemLoaded(index, items)) {\n        unloadedRanges[0] = firstUnloadedStart = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\nconst defaultIsItemLoaded = <Item>(index: number, items: Item[]): boolean =>\n  items[index] !== void 0;\n\nexport interface UseInfiniteLoaderOptions<Item> {\n  /**\n   *  A callback responsible for determining the loaded state of each item. Should return `true`\n   * if the item has already been loaded and `false` if not.\n   *\n   * @default (index: number, items: any[]) => boolean\n   */\n  isItemLoaded?: (index: number, items: Item[]) => boolean;\n  /**\n   * The minimum number of new items to be loaded at a time.  This property can be used to\n   * batch requests and reduce HTTP requests.\n   *\n   * @default 16\n   */\n  minimumBatchSize?: number;\n  /**\n   * The threshold at which to pre-fetch data. A threshold X means that new data should start\n   * loading when a user scrolls within X cells of the end of your `items` array.\n   *\n   * @default 16\n   */\n  threshold?: number;\n  /**\n   * The total number of items you'll need to eventually load (if known). This can\n   * be arbitrarily high if not known.\n   *\n   * @default 9e9\n   */\n  totalItems?: number;\n}\n\nexport type LoadMoreItemsCallback<Item> = (\n  startIndex: number,\n  stopIndex: number,\n  items: Item[]\n) => any;\n\nconst emptyObj = {};\n","import * as React from \"react\";\nimport { Masonry } from \"./masonry\";\nimport type { MasonryProps } from \"./masonry\";\n\n/**\n * This is just a single-column `<Masonry>` component without column-specific props.\n *\n * @param props\n */\nexport function List<Item>(props: ListProps<Item>) {\n  return (\n    <Masonry<Item>\n      role=\"list\"\n      rowGutter={props.rowGutter}\n      columnCount={1}\n      columnWidth={1}\n      {...props}\n    />\n  );\n}\n\nexport interface ListProps<Item>\n  extends Omit<\n    MasonryProps<Item>,\n    \"columGutter\" | \"columnCount\" | \"columnWidth\"\n  > {\n  /**\n   * The amount of vertical space in pixels to add between the list cells.\n   *\n   * @default 0\n   */\n  rowGutter?: number;\n}\n\nif (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n  List.displayName = \"List\";\n}\n"],"names":["updateMax","node","max","high","L","NULL_NODE","R","Math","updateMaxUp","x","P","rotateLeft","tree","y","root","rotateRight","replaceNode","createIntervalTree","size","indexMap","insert","low","index","treeNode","prevNode","list","next","addInterval","z","C","fixInsert","remove","intervalResult","removeInterval","originalYColor","minimumTree","w","fixRemove","search","callback","stack","length","pop","push","curr","useEvent","target","type","listener","cleanup","storedListener","React","useRef","storedCleanup","useEffect","current","didUnsubscribe","args","apply","this","targetEl","addEventListener","removeEventListener","useForceUpdate","setState","useState","emptyObj","useMasonry","stopIndex","positioner","resizeObserver","items","as","ContainerComponent","id","className","style","role","tabIndex","containerRef","itemAs","ItemComponent","itemStyle","itemHeightEstimate","itemKey","defaultGetItemKey","overscanBy","scrollTop","isScrolling","height","RenderComponent","render","onRender","startIndex","forceUpdate","setItemRef","getRefSetter","itemCount","columnWidth","columnCount","range","estimateHeight","shortestColumn","measuredCount","shortestColumnSize","children","itemRole","undefined","storedOnRender","useLatest","rangeEnd","needsFreshBatch","left","top","data","key","phaseTwoStyle","width","writingMode","position","__reactCreateElement__","ref","_extends","createRenderElement","min","batchSize","ceil","phaseOneStyle","getCachedSize","didEverMount","containerStyle","getContainerStyle","assignUserStyle","_","i","useThrottleCallback","fps","leading","prev","clearTrailing","storedCallback","ms","trailingTimeout","clearTimeout","deps","useCallback","arguments","rightNow","now","call","setTimeout","useScroller","offset","useScrollPosition","setIsScrolling","didMount","fn","start","handle","to","v","raf","loop","caf","clearRequestTimeout","MasonryScroller","props","scrollFps","useContainerPosition","elementRef","emptyArr","containerPosition","setContainerPosition","useLayoutEffect","el","offsetTop","offsetParent","offsetWidth","usePositioner","columnGutter","rowGutter","maxColumnCount","initPositioner","getColumns","computedColumnWidth","computedColumnCount","createPositioner","positionerRef","prevDeps","opts","prevOpts","optsChanged","every","item","prevPositioner","cacheSize","pos","get","set","useResizeObserver","disconnect","createResizeObserver","handler","cancel","useScrollToIndex","options","align","element","window","innerHeight","latestOptions","getTarget","latestElement","useReducer","state","action","nextState","prevTop","value","defaultState","dispatch","throttledDispatch","currentTop","_latestOptions$curren","scrollTo","timeout","estimatedTop","Masonry","windowSize","wait","initialWidth","initialHeight","initialState","useDebounceCallback","useDebounce","document","getSize","setDebouncedSize","setSize","win","wv","useWindowSize","ssrWidth","ssrHeight","containerPos","nextProps","scrollToIndex","storedValue","visualViewport","documentElement","clientWidth","clientHeight","areEqual","equal","defaultAreEqual","val","k","createCache","obj","e","cache","mapConstructors","constructors","base","map","depth","baseCache","one","g","s","elementsCache","WeakMap","trieMemoize","OneKeyMap","memoizeOne","maxWidth","maxHeight","willChange","pointerEvents","cmp2","pargs","userStyle","zIndex","visibility","observe","offsetHeight","u","p","performance","Date","af","Caf","Raf","bind","lastTime","h","perf","getScrollY","scrollY","pageYOffset","useThrottle","createElement","intervalTree","columnHeights","Array","columnItems","column","update","updates","columns","j","itemsInColumn","binarySearch","startItem","lo","hi","renderCallback","defaultItemHeight","tallestColumn","all","a","l","m","minimumWidth","gutter","floor","Infinity","frameId","lastArgs","wrapperFn","_len","_key","requestAnimationFrame","cancelAnimationFrame","updater","rafSchd","commonHandler","handlers","Map","ro","ResizeObserver","entries","entry","forEach","defaultIsItemLoaded","loadMoreItems","isItemLoaded","minimumBatchSize","threshold","totalItems","storedLoadMoreItems","storedIsItemLoaded","unloadedRanges","rangeStartIndex","rangeStopIndex","potentialStopIndex","firstUnloadedStart","firstUnloadedStop","scanForUnloadedRanges"],"mappings":"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"}